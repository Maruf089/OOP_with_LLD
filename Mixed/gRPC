gRPC - Google Remote Procedure Call

is a high-performance, open-source RPC framework from Google.

It uses:

- HTTP/2 for transport
- Protocol Buffers (protobuf) for data serialization
- Binary format → extremely fast, efficient
- Strong typing with auto-generated code
- Cross-language support
- Bidirectional streaming, not just request/response

How gRPC Works

- You define service and message schema in a .proto file.
- Use the protobuf compiler (protoc) to generate client/server code.
- Implement server logic.
- Call the server using the auto-generated client stubs.


How to Set Up gRPC With Protocol Buffers (Java Example)

(Let me know if you want Go, Python, Node, or C# instead.)

1. Add Dependencies
Maven
<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-netty-shaded</artifactId>
    <version>1.65.0</version>
</dependency>

<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-protobuf</artifactId>
    <version>1.65.0</version>
</dependency>

<dependency>
    <groupId>io.grpc</groupId>
    <artifactId>grpc-stub</artifactId>
    <version>1.65.0</version>
</dependency>

<plugin>
    <groupId>org.xolstice.maven.plugins</groupId>
    <artifactId>protobuf-maven-plugin</artifactId>
    <version>0.6.1</version>
    <configuration>
        <protocArtifact>
            com.google.protobuf:protoc:3.25.1:exe:${os.detected.classifier}
        </protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>
            io.grpc:protoc-gen-grpc-java:1.65.0:exe:${os.detected.classifier}
        </pluginArtifact>
    </configuration>
</plugin>

2. Create a .proto File

src/main/proto/hello.proto

syntax = "proto3";

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}


This schema drives the whole system.

3. Generate Java Classes

Run:

mvn clean package


This generates:

GreeterGrpc.java → service stub + client stub

HelloRequest.java, HelloReply.java → protobuf messages

4. Implement the gRPC Server
public class HelloService extends GreeterGrpc.GreeterImplBase {

    @Override
    public void sayHello(HelloRequest request,
                         StreamObserver<HelloReply> responseObserver) {

        String greeting = "Hello " + request.getName();
        HelloReply reply = HelloReply.newBuilder()
                                     .setMessage(greeting)
                                     .build();

        responseObserver.onNext(reply);
        responseObserver.onCompleted();
    }
}

5. Start the Server
public class GrpcServer {
    public static void main(String[] args) throws Exception {
        Server server = ServerBuilder
                .forPort(8080)
                .addService(new HelloService())
                .build()
                .start();

        System.out.println("Server started at 8080");
        server.awaitTermination();
    }
}

6. Create a gRPC Client
public class GrpcClient {
    public static void main(String[] args) {
        ManagedChannel channel = ManagedChannelBuilder
                .forAddress("localhost", 8080)
                .usePlaintext()
                .build();

        GreeterGrpc.GreeterBlockingStub stub =
                GreeterGrpc.newBlockingStub(channel);

        HelloReply reply = stub.sayHello(
                HelloRequest.newBuilder().setName("Maruf").build()
        );

        System.out.println(reply.getMessage());
    }
}

Why Protocol Buffers (Protobuf) Is Fast?

Protobuf uses:

Binary format (not text like JSON)

Field numbers instead of field names → smaller payload

Strict schema → predictable, optimized parsing

Zero-copy deserialization in some languages

This makes it much faster + smaller than JSON/XML.




